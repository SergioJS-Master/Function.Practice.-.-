console.log('================Функции===============');

function myFn(a, b) { //объявленная функция(Function Declaration)
  let c
  a = a + 1;
  c = a + b;
  return c  
}

let myFn1 = function(a, b) { //функциональное выражения(Function Expression) отличается от
  let c                      //классического объявление функции - отсутствием имени
  a = a + 1;
  c = a + b;
  return c  
}
//эти виды функций, можно использовать как аргументы в вызове другой функции(колбэк)


console.log('____________Задание 1________');

let pricE = 80000

function priceMessage(pricE){
  console.log(`Данный товар стоит ${pricE} рублей`)
}

priceMessage(pricE)

console.log('____________Задание 2______________');

//Задание с возвратом return

/*В программе объявлены две переменные с числовым значением — num_1 и num_2.
Напишите функцию mult, которая принимает два аргумента и возвращает их произведение. 
Вызовите функцию mult и передайте ей в качестве аргументов значения переменных num_1 и num_2, а результат выведите в консоль.

Пример значений переменных:
num_1 = 3
num_2 = 6
Пример результата: 18*/

let num_1 = 3;
let num_2 = 6;

function mult (num_1, num_2){
  return num_1 * num_2
} 
console.log(mult (num_1, num_2));


console.log('____________Задание  3________');

/*В программе объявлена переменная num, в которую записано числовое значение. 
Напишите функцию square(), которая возвращает квадрат этого числового значения. 
Обратите внимание, что функция обращается к глобальной переменной, а не получает значение в качестве аргумента.

Пример значений переменных:
num = 9

Пример результата: 81*/

let num = 9

function squarE(){
  return Math.pow(num, 2)
}
console.log(squarE());

console.log('____________Задание  4________');

/*В программе объявлена переменная data, в которой записано строковое значение. 
Напишите функцию getNumber(data), которая преобразовывает строку в число по следующему правилу:
если переменная data содержит не число, функция должна вернуть численное значение 0;
если переменная data содержит число, например "123", то функция возвращает числовое значение 123.
Вызовите эту функцию и выведите результат в консоль.

Пример значений переменных:
data = "привет"

Пример результата:0*/

let data = "привет"

function getNumber(data){
  if(parseInt(data) <= 0 || parseInt(data) >= 0){
      console.log(0);
  }else{
      console.log(123);
  }
}
getNumber(data)


console.log('____________Стрелочные функции________');

// простая запись стрелочной функции 

const square = (a, b) => { //стрелочные функции это выражения   
                           //=> значит всегда - анонимные 
  let c 
  a = a + 1;
  c = a + b;
  return c 
}
// сокращенная запись той же стрелочной функции 

const someVariable = () => expression // если у стрелочной функции одно выражение, то фигурные скобки можно опустить 
                                      // и в таком случае результат выражения будет возвращен автоматически, return можно не использовать (нявный возрат значения) 
                                     

console.log('____________Значение параметов функции по умолчанию________');

function multByFactor(value, multiplier = 1) { // если значение для параметра multiplier не будет в вызое функции, то этому параметру будет присв. значение - 1 
  return value * multiplier; //(Function Declaration)
}
multByFactor(10, 2) // 20
multByFactor(5) // 5

const multByFactor1 = function(value, multiplier = 1) { //анонимнок функциональное выражение (Function Expression)
  return value + multiplier; 
}

const multByFactor2 = ((value, multiplier = 1) => value - multiplier); //(Function Expression) более сокращенная форма записи - стрелочная функция
// с одним выражением и возврат значяения происходит в таком случа НЕЯВНО 


console.log('____________Значение параметров функции по умолчанию 2________');

const newPost1 = (post, addedAt = Date()) => ({ //Date() формирует актуальную дату и время вызова(дефолтное значение в нашем варианте)
  ...post, //спред оператор разделения объекта на свойства с сохранением свойств и значений
  addedAt, // добавление к объекты вывод даты и времени
}) //в этом варианте необычный синтаксис после (=>) у нас открываются скобки и в этих скобках формируется новый объект
   // если бы мы не написали скобки то JS воспринял бы такой синтаксис как начало функции
   // такой вариант называется неявным возвратом объекта
const firstPost1 = {
  id: 1,
  author: 'Sergey'
}

console.log(newPost1(firstPost1)); //вызов объекта по ссылке и присваивание дефолтного значения addedAt  


console.log('____________Обработка ошибок________');

const fnWithError = () => {
  throw new Error('Some error'); //(throw new Error) с помощью такой инструкции мы может сгенерировать какую-то ошибку в JS 
} //ошибки кода в JS приводят к остановке выполнения кода

fnWithError()//в данном коде выполение кода остановится в момент вызова функции
//это будет Uncaught ошибка(не пойманая ошибка = код остановлен)
console.log('Continue...');

//Решение в случае появление различных ошибок 
try {
  //Выполнение блока кода
} catch (error) { //(error) - это параметр как в функции
  //Этот блок выполняется в случае возникновения ошибок в блоке try
}

//пример

const fnWithError1 = () => {
  throw new Error('Some error'); 
}

try {//в try у нас находится вызов функции. Теперь вызов находится здесь
  fnWithError1()//в catch мы выполн. действия в случае возникновения ошибки
} catch (error) {//ошибка будет присвоена как значение переменной error
  console.error(error);//мы эту ошибку сможем напечетать в console.error
//console.error отразит ошибку в красном цвете. Но в данном случак, мы поймаем эту ошибку
  console.log(error.message);//в данном прим. мы вывед. ошибку в консоль. Также, у каждой 
//ошибки (ошибка=объект) есть свойство message. message это сам error. message позволит вывести ТОЛЬКО сообщение об ошибке
}
//если мы поймали ошибку с помощью try/catch то выполнение кода продолжится. Для этого и нужно использовтаь этот метод
console.log('Continue...');



console.log('____________Колбеки________');

//пример колбек функции

function stringToNumber(str, onOk, onError) {
if (typeof str !== 'string') {
  onError("Введенное значение не строка!");
  return;
}
if (!isNaN(str) && !isNaN(parseFloat(str))) {
  onOk(Number(str));
} else {
  onError("Введенная строка не является корректным числом")
}
}

function printNums(number) {
for (let i = 0; i <= number; i++) {
  console.log(i);
}
}

stringToNumber("3", printNums, function handleError(message) {
console.error(message);
})  

// В данном примере мы написали функцию, которая пытается преобразовать строку в число 
// и при успехе вызывает onOk, 
// а при ошибках onError.
// Вызвав функцию, в качестве onOk мы передали существующую функцию printNums. 
// Обратите внимание: мы не вызываем функцию, а передаем ее. 
// А в качестве onError мы прямо на месте написали функцию handleError, 
// которая принимает и выводит ошибки.


console.log('____________Итерация массива с использованием функций(колбэк)________');


//вывод значений массива arr  через 1,1 секунду поочередно с использованием функции 
const arrName = ['Sergey', 'Alexander', 'Viktor', 'Pavel'];

function arrTime (arr) {
for(let i = 0; i < arr.length; i++) {
    setTimeout(function () {
      console.log(`${i + 1}) ${arr[i]}`)
    }, (i + 1) * 1100)
  }
    return arr
}

arrTime(arrName)

//сокращенный вариант с использованием стрелочной функции и метода forEach()
const arrName2 = ['Sergey', 'Alexander', 'Viktor', 'Pavel'];
arrName2.forEach((el, i) => {
    setTimeout(() => {
      console.log(el)
    }, (i + 1) * 1100)
  })

//вывод эл. массива с использованием колбэк функций и метода setTimeout

const arrName3 = ['Sergey', 'Alexander', 'Viktor', 'Pavel'];
function arrFor (a) {
    for(let i = 0; i < a.length; i++){
        console.log(`${i + 1}) ${a[i]}`);
    }
    return a
}
const colbackArrFor = function() { //обращение к к этой анонимной функции будет происходить следующим образом - colbackArrFor()
    arrFor(arrName3) 
}

setTimeout(colbackArrFor, 1000);


console.log('____________строгий режим________');

'use strict';//запрещается использования необъяленных переменных
//если не использовать строгий режим, то при обращении к какой либо переменной, которая не объявл. в обла. видимости функции, то эта 
//функция, будет объявл. в глобальной обл. видимости. Так делать НЕ рекомендуется
//чтобы этого избежать, и избежать изменения внешних переменных внутри функции, используют метод 'use strict'
function myFn_1() {
  a = true // Uncaught ReferenceError: a is not defined at muFn_1
  console.log(a);
}

myFn_1()
console.log(a);